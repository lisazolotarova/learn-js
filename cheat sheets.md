## Functions

Передаваемые значения копируются в параметры функции и становятся локальными переменными.
Функции имеют доступ к внешним переменным. Но это работает только изнутри наружу. Код вне функции не имеет доступа к её локальным переменным.
Функция может возвращать значение. Если этого не происходит, тогда результат равен undefined.

Если функция объявлена как отдельная инструкция в основном потоке кода, то это Function Declaration. Function Declaration обрабатываются перед выполнением блока кода. 
Они видны во всём блоке. Если функция была создана как часть выражения, то эта функция объявлена при помощи Function Expression. 

Фабричная функция — это функция, которая принимает несколько аргументов и возвращает новый объект, состоящий из этих аргументов. 

## Loops

while – Проверяет условие перед каждой итерацией.
do..while – Проверяет условие после каждой итерации.
for (;;) – Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.

Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву continue.

## Objects

Получить доступ к свойству:
Запись через точку: obj.property.
Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].

Удаление свойства: delete obj.prop.
Проверка существования свойства: "key" in obj.
Перебор свойств объекта: цикл for for (let key in obj).

Для «простого клонирования» объекта используется Object.assign. Object.assign не делает глубокое клонирование объекта. 
Если внутри копируемого объекта есть свойство, которое не является примитивом, оно будет передано по ссылке.

## Scope

глобальная (переменная или функция, созданная в этой области видимости, может быть доступна из любой точки программы);
локальная или функциональная (переменная или функция, созданная в этой области видимости, может быть доступна только внутри неё).

var объявляет переменные с функциональной областью видимости, а let и const c блочной, при этом const нельзя менять, но если например объявить объект через const, 
его значения можно менять, потому что данные объекта передаются по ссылке.

## Prototypal inharitance

Свойство __proto__ — исторически обусловленный геттер/сеттер для [[Prototype]]

let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};
rabbit.__proto__ = animal;

alert( rabbit.eats ); // true (**)
alert( rabbit.jumps ); // true

Здесь мы можем сказать, что "animal является прототипом rabbit" или "rabbit прототипно наследует от animal".
! Прототипы никак не влияют на this. Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.

Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key): он возвращает true, 
если у obj есть собственное, не унаследованное, свойство с именем key.

Почти все остальные методы, получающие ключи/значения, такие как Object.keys, Object.values и другие – игнорируют унаследованные свойства.
Они учитывают только свойства самого объекта, не его прототипа.

**Ограничения:**
1. Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить __proto__ по кругу.
2. Значение __proto__ может быть объектом или null. Другие типы игнорируются.

## OOP
### Инкапсуляция
Инкапсуляция защищает от влияния извне внутренние переменные каждого объекта. В идеале программа должна состоять из «островов объектов»: каждый из них со своими состояниями, передающий сообщения туда и обратно.

### Полиморфизм
Полиморфизм позволяет описывать поведение вне зависимости от типа данных. В ООП это означает создание класса или прототипа, который может быть адаптирован объектами, работающими с другими типами данных. Объекты, которые используют полиморфный класс/прототип, должны определить специфичное для типа данных поведение, чтобы всё заработало.

