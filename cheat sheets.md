## Functions

Передаваемые значения копируются в параметры функции и становятся локальными переменными.
Функции имеют доступ к внешним переменным. Но это работает только изнутри наружу. Код вне функции не имеет доступа к её локальным переменным.
Функция может возвращать значение. Если этого не происходит, тогда результат равен undefined.

Если функция объявлена как отдельная инструкция в основном потоке кода, то это Function Declaration. Function Declaration обрабатываются перед выполнением блока кода. 
Они видны во всём блоке. Если функция была создана как часть выражения, то эта функция объявлена при помощи Function Expression. 

Фабричная функция — это функция, которая принимает несколько аргументов и возвращает новый объект, состоящий из этих аргументов. 

### Функция-конструктор
Использование конструкторов для создания объектов даёт большую гибкость. Можно передавать конструктору параметры, определяющие, как создавать объект, 
и что в него записывать. Функции-конструкторы или просто конструкторы являются обычными функциями, именовать которые следует с заглавной буквы.
Конструкторы следует вызывать при помощи оператора new. Такой вызов создаёт пустой this в начале выполнения и возвращает заполненный в конце.

**Возврат значения из конструктора return**
Обычно конструкторы ничего не возвращают явно. Их задача – записать все необходимое в this, который в итоге станет результатом. Но если return всё же есть, то применяется простое правило:

- При вызове return с объектом, будет возвращён объект, а не this.
- При вызове return с примитивным значением, примитивное значение будет отброшено.
- Другими словами, return с объектом возвращает объект, в любом другом случае конструктор вернёт this.

## Loops

while – Проверяет условие перед каждой итерацией.
do..while – Проверяет условие после каждой итерации.
for (;;) – Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.

Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву continue.

## Objects

Получить доступ к свойству:
Запись через точку: obj.property.
Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].

Удаление свойства: delete obj.prop.
Проверка существования свойства: "key" in obj.
Перебор свойств объекта: цикл for for (let key in obj).

Для «простого клонирования» объекта используется Object.assign. Object.assign не делает глубокое клонирование объекта. 
Если внутри копируемого объекта есть свойство, которое не является примитивом, оно будет передано по ссылке.

## Scope

глобальная (переменная или функция, созданная в этой области видимости, может быть доступна из любой точки программы);
локальная или функциональная (переменная или функция, созданная в этой области видимости, может быть доступна только внутри неё).

var объявляет переменные с функциональной областью видимости, а let и const c блочной, при этом const нельзя менять, но если например объявить объект через const, 
его значения можно менять, потому что данные объекта передаются по ссылке.

## Prototypal inharitance

Свойство __proto__ — исторически обусловленный геттер/сеттер для [[Prototype]]

let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};
rabbit.__proto__ = animal;

alert( rabbit.eats ); // true (**)
alert( rabbit.jumps ); // true

Здесь мы можем сказать, что "animal является прототипом rabbit" или "rabbit прототипно наследует от animal".
! Прототипы никак не влияют на this. Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.

Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key): он возвращает true, 
если у obj есть собственное, не унаследованное, свойство с именем key.

Почти все остальные методы, получающие ключи/значения, такие как Object.keys, Object.values и другие – игнорируют унаследованные свойства.
Они учитывают только свойства самого объекта, не его прототипа.

**Ограничения:**
1. Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить __proto__ по кругу.
2. Значение __proto__ может быть объектом или null. Другие типы игнорируются.

### Инкапсуляция
Инкапсуляция нужна для защиты какой-то внутренней логики от случайного/намеренного изменения, которое может вызвать внутренние проблемы.

### Полиморфизм
Полиморфизм позволяет описывать поведение вне зависимости от типа данных. В ООП это означает создание класса или прототипа, который может быть адаптирован объектами, работающими с другими типами данных. Объекты, которые используют полиморфный класс/прототип, должны определить специфичное для типа данных поведение, чтобы всё заработало. 
Это практика проектирования объектов для совместного использования поведения и возможности переопределения общего поведения конкретными объектами. Полиморфизм использует преимущества наследования для того, чтобы это произошло.

## Classes
Расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы). Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д.

Базовый синтаксис для классов выглядит так:
class MyClass {
  prop = value; // свойство
  constructor(...) { // конструктор
    // ...
  }
  method(...) {} // метод
  get something(...) {} // геттер
  set something(...) {} // сеттер
  [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
  // ...
}

**[[HomeObject]]**
Единственное место в языке, где используется [[HomeObject]] – это super. Поэтому если метод не использует super, то мы все ещё можем считать его свободным и копировать между объектами. А вот если super в коде есть, то возможны побочные эффекты.

Когда функция объявлена как метод внутри класса или объекта, её свойство [[HomeObject]] становится равно этому объекту. Затем super использует его, чтобы получить прототип родителя и его методы.

Свойство [[HomeObject]] определено для методов как классов, так и обычных объектов. Но для объектов методы должны быть объявлены именно как method(), а не "method: function()".

**Возможно, важно**
- Если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся такой «пустой» конструктор
- Синтаксис классов отличается от литералов объектов – внутри классов запятые не требуются.
- У функций-стрелок нет своего this и super, поэтому они «прозрачно» встраиваются во внешний контекст.

Чтобы унаследовать от класса: class Child extends Parent:
При этом Child.prototype.__proto__ будет равен Parent.prototype, так что методы будут унаследованы.

**При переопределении конструктора:**
Обязателен вызов конструктора родителя super() в конструкторе Child до обращения к this.

**При переопределении другого метода:**
Мы можем вызвать super.method() в методе Child для обращения к методу родителя Parent.

**Внутренние детали:**
Методы запоминают свой объект во внутреннем свойстве [[HomeObject]]. Благодаря этому работает super, он в его прототипе ищет родительские методы.
Поэтому копировать метод, использующий super, между разными объектами небезопасно.

## Замыкание
**Что такое замыкание?** Это объект, связанный и с функцией-объектом и scope-объектом. На самом деле, все функции в JavaScript это замыкания: невозможно иметь ссылку на функцию-объект без scope-объекта.

**Когда замыкание создается?** Так как все функции в JavaScript это замыкания, ответ очевиден: когда задается функция — задается замыкание. Так что замыкание создается при определении функции. Но нужно понимать разницу между созданием замыкания и созданием нового scope-объекта: замыкание (функция + ссылка на текущую цепочку scope-объектов) создается при определении функции, но новый scope-объект создается (и используется для модификации цепочки scope-объектов замыкания) при вызове функции.

**Когда замыкание уничтожается?** Как любой другой объект в JavaScript, сборщик мусора обрабатывает замыкание когда на него больше нет ссылок.
